//////////////////////////////////////////////////////////////////
//
// 			TO DO 					// 
//////////////////////////////////////////////////////////////////

// GET START POS FOR MC/RECO MICHEL AND RECO MUON
// GET TRAJECTORY ANGLE FOR MC/RECO MUON/MICHEL
// CREATE BOOLEAN FOR IF VERTEX IS AT WRONG END OF MUON
// N Clusters for reco particles
// Find neutrino interactrion vertex

///////////////////////////////////////////////////////////////////////
// Class:       AnalyzeMichels
// Plugin Type: analyzer (Unknown Unknown)
// File:        AnalyzeMichels_module.cc
//
// Generated at Wed Oct 13 08:28:13 2021 by Edward Tyley using cetskelgen
// from  version .
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art_root_io/TFileService.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCTrajectory.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "canvas/Persistency/Common/FindManyP.h"   // Find associations as pointers
#include "canvas/Persistency/Common/FindOneP.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "sbndcode/RecoUtils/RecoUtils.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include <stdio.h>
#include <stdlib.h>
#include "lardataobj/RecoBase/Slice.h"

#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "larsim/Utils/TruthMatchUtils.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"

#include "art/Utilities/ToolMacros.h"

//LArSoft Includes
#include "larpandora/LArPandoraEventBuilding/LArPandoraShower/Tools/IShowerTool.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/PFParticle.h"

// ROOT includes
#include <TH1F.h>
#include <TTree.h>
#include<THStack.h>
#include<TMath.h>

// STL includes
#include <string>
#include <vector>
#include <iostream>

namespace sbnd {
class AnalyzeMichels;
}



class sbnd::AnalyzeMichels : public art::EDAnalyzer {
  public:
  explicit AnalyzeMichels(fhicl::ParameterSet const& p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  AnalyzeMichels(AnalyzeMichels const&) = delete;
  AnalyzeMichels(AnalyzeMichels&&) = delete;
  AnalyzeMichels& operator=(AnalyzeMichels const&) = delete;
  AnalyzeMichels& operator=(AnalyzeMichels&&) = delete;

  // Required functions.
  void analyze(art::Event const& e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

  private:

  void rotateVector(TVector3 *vector);  // Rotates components of 3-vector clockwise e.g. XTZ -> ZXY

  void ResetVars();

  void FillMC(const art::Ptr<simb::MCParticle>& mcp, std::vector<art::Ptr<simb::MCParticle>>& mctruthVect);
  void FillRecoMuon();

  // Create out output tree
  TTree* fTree;

  // Create our output histograms

  TH1D *fMCMichelEnergyHist;
  TH1D *fMCMuonEnergyHist;
  TH1D *fRecoMuonEnergyHist;
  TH1D *fRecoMichelEnergyHist;
  TH1D *fMCMichelThetaHist;
  TH1D *fMCMuonThetaHist;
  TH1D *fRecoMichelThetaHist;
  TH1D *fRecoMuonThetaHist;
  TH1D *fMCMichelPhiHist;
  TH1D *fMCMuonPhiHist;
  TH1D *fRecoMichelPhiHist;
  TH1D *fRecoMuonPhiHist;
  TH1D *fMCMichelRelThetaHist;
  TH1D *fRecoMichelRelThetaHist;
  TH1D *fMCMichelRelPhiHist;
  TH1D *fRecoMichelRelPhiHist;
  TH1D *fMCMichelLengthHist;


  // Event Variables
  int fEventID;
  int fNPFParticles;
  std::vector<int> fPFParticlePDG;
  int fEventNHits;
  int fEventNClusterHits;		// No hits in event associated with a cluster
  int fNRecoElectrons;
  std::vector<int> fMCPDG;
  std::vector<int> fMCTrackID;
  std::vector<int> fNHitsInPFP;
  std::vector<int> fNTrueHitsInPFP;
  std::vector<int> fNClusters;
  bool fWrongMuonEnd;
  std::vector<int> fClusterID;
  std::vector<std::string> fClusterPlane;
  int fNMuons;
  float fRecoMuonMichelDist;
  std::vector<bool> fPFPIsPrimary;
  std::vector<int> fPFPMother;
  int fNMuonsWithTrueHits;
  float fMaxSADCX;
  float fMaxSADCY;
  float fMaxSADCZ;
  float fMaxSADCDist;  // Distance from hit with highest SADC integral to michel/muon vertex
  float fMaxAmpX;
  float fMaxAmpY;
  float fMaxAmpZ;
  float fMaxAmpDist;   // Distnace from hit with max peak amplitude to michel/muon vertex
  float fAmpMean;
  float fAmpSigma;
  float fSADCMean;
  float fSADCSigma;
  int fNSlices;
  int fNMichelNonClust;	// No. of non-clustered Michel hits in event

  // MC Michel
  int fMCMichelID;
  float fMCMichelEnergy;
  float fMCMichelTheta;
  float fMCMichelPhi;
  float fMCMichelRelTheta;
  float fMCMichelRelPhi;
  TVector3 *fMCMichelVect;
  float fMCMichelLength;
  float fMCMichelStartX;
  float fMCMichelStartY;
  float fMCMichelStartZ;
  float fMCMichelRelAngle;
  int fMCMichelNPoints;
  float fMCMichelEnergyFrac;		// Fraction of end MC muon energy taken by michel

  float fPurity;
  float fCompleteness;
  int fNHitsInRecoMichel;
  int fNTotalMichelHits;
  int fNShowers;
  int fNTracks;
  bool fRecoMichel;
  float fShowerPurity;
  float fTrackPurity;
  int fShowerBestPlane;
  bool fIsTrack;
  bool fIsShower;
  int fNTrueHitsInRecoMichel;
  float fRecoMichelEnergy;
  float fRecoMichelTheta;
  float fRecoMichelPhi;
  float fRecoMichelRelTheta;
  float fRecoMichelRelPhi;
  float fRecoMichelRelAngle;
  TVector3 *fRecoMichelVect;
  float fRecoMichelStartX;
  float fRecoMichelStartY;
  float fRecoMichelStartZ;
  int fRecoMichelID;
  int fRecoMichelMother;
  int fNRecoMichelSpacePoints;
  float fRecoMichelLength;
  float fRecoMichelAzi;
  float fRecoMichelZen;
  float fRecoMichelCloseProximity;		// Distance between closest two hits
  int fRecoMichelNClusters;
  float fRecoMichelEnergySigma;
  std::vector<double> fRecoMicheldEdX;
  std::vector<float> fRecoMichelHitIntegral;
  std::vector<float> fRecoMichelHitPeakTime;
  std::vector<float> fRecoMichelHitNElectrons;
  std::vector<int> fRecoMichelHitPlane;
  float fRecoMichelEnergyU;
  float fRecoMichelEnergyV;
  float fRecoMichelEnergyW;
  float fRecoMichelEnergyDiffU;
  float fRecoMichelEnergyDiffV;
  float fRecoMichelEnergyDiffW;
  float fRecoMichelIntegralMaxU;
  float fRecoMichelIntegralMeanU;
  float fRecoMichelIntegralSigmaU;
  float fRecoMichelIntegralMaxV;
  float fRecoMichelIntegralMeanV;
  float fRecoMichelIntegralSigmaV;
  float fRecoMichelIntegralMaxW;
  float fRecoMichelIntegralMeanW;
  float fRecoMichelIntegralSigmaW;
  float fRecoMichelMultiplicityMaxU;
  float fRecoMichelMultiplicityMeanU;
  float fRecoMichelMultiplcitySigmaU;
  float fRecoMichelGOFMaxU;
  float fRecoMichelGOFSigmaU;
  float fRecoMichelGOFMeanU;
  float fRecoMichelMultiplicityMaxV;
  float fRecoMichelMultiplicityMeanV;
  float fRecoMichelMultiplcitySigmaV;
  float fRecoMichelGOFMaxV;
  float fRecoMichelGOFSigmaV;
  float fRecoMichelGOFMeanV;
  float fRecoMichelMultiplicityMaxW;
  float fRecoMichelMultiplicityMeanW;
  float fRecoMichelMultiplcitySigmaW;
  float fRecoMichelGOFMaxW;
  float fRecoMichelGOFSigmaW;
  float fRecoMichelGOFMeanW;
  std::vector<float> fRecoMichelhitMultiplicity;
  std::vector<float> fRecoMichelHitGOF;
  float fRecoMichelEDiffMin;
  float fRecoMichelEDiffMinGOF;
  float fRecoMichelEDiffMinMult;
  float fRecoMichelPurityU;
  float fRecoMichelPurityV;
  float fRecoMichelPurityW;
  float fRecoMichelEPurityU;
  float fRecoMichelEPurityV;
  float fRecoMichelEPurityW;
  float fRecoMichelEPurity;
  std::vector<int> fRecoMichelPlaneIndex;
  std::vector<float> fRecoMichelEnergyDiffVect;
  std::vector<float> fRecoMichelEPurityVect;
  std::vector<float> fRecoMichelEnergyVect;
  std::vector<float> fRecoMichelPurityVect;
  std::vector<float> fRecoMichelcompletenessVect;
  std::vector<float> fRecoMichelGOFMeanVect;
  std::vector<float> fRecoMichelGOFSigmaVect;
  std::vector<float> fRecoMichelGOFMaxVect;
    std::vector<float> fRecoMichelMultMeanVect;
  std::vector<float> fRecoMichelMultSigmaVect;
  std::vector<float> fRecoMichelMultMaxVect;
  std::vector<float> fRecoMichelIntegralMeanVect;
  std::vector<float> fRecoMichelIntegralSigmaVect;
  std::vector<float> fRecoMichelIntegralMaxVect;
  std::vector<int> fRecoMichelNHitsPlane;
  TVector3 *fRecoMichelStartVect;

  // MC Muon
  int fMCMuonG4ID;
  int fNDeltas;
  int fNPoints;
  int fNElectronsWithTrueHits;
  float fMCMuonEnergy;
  float fMCMuonTheta;
  float fMCMuonPhi;
  TVector3 *fMCMuonVect;
  float fMCMuonEndX;
  float fMCMuonEndY;
  float fMCMuonEndZ;
  float fMCMuonEndEnergy;
  float fMCMuonEndPx;
  float fMCMuonEndPy;
  float fMCMuonEndPz;
  float fMCMuonStartX;
  float fMCMuonStartY;
  float fMCMuonStartZ;
  float fMCMuonBendiness;

  // Reco Muon
  int fNRecoMuonHits;
  float fRecoMuonEnergy;
  float fRecoMuonTheta;
  float fRecoMuonPhi;
  TVector3 *fRecoMuonVect;
  int fRecoMuonID;
 float fRecoMuonStartX;
  float fRecoMuonStartY;
  float fRecoMuonStartZ;
  float fRecoMuonEndX;
  float fRecoMuonEndY;
  float fRecoMuonEndZ;
  int fRecoMuonCheckHits;
  int fNRecoMuonSpacePoints;
  bool fRecoMuonIsPrimary;
  int fRecoMuonMother;
  int fNTrueHitsInRecoMuon;
  float fRecoMuonAzi;
  float fRecoMuonZen;
  int fRecoMuonNClusters;
  std::vector<int> fRecoMuonNHitsPlane;
  std::vector<float> fRecoMuonEndBendinessVect;
  TVector3 *fRecoMuonEndVect;

  // NonClustered Hits
  std::vector<float> fNonClustX;
  std::vector<float> fNonClustY;
  std::vector<float> fNonClustZ;
  std::vector<float> fNonClustDist;		// Distance of non-clustered hit to MC Michel start
  std::vector<float> fNonClustMaxAmp;
  std::vector<float> fNonClustSADC;
  std::vector<int> fNonClustPlane;
  std::vector<bool> fNonClustIsMichel;

  calo::CalorimetryAlg fCalorimetryAlg;

  // Temporary variables
  int countpfps;
  std::string lastchar;

  // Define input labels
  const std::string fPFParticleLabel;
  const std::string fHitLabel;
  const std::string fTrackLabel;
  const std::string fShowerLabel;
  const std::string fCaloLabel;
  const std::string fMCTruthLabel;
  const std::string fClusterLabel;
  const std::string fHitClusterLabel;
  const std::string fHitShowerLabel;
  const std::string fHitTrackLabel;
  const std::string fHitSpacePointLabel;
  const std::string fTrackCaloLabel;
  const int sUseWPlaneOnly;
  const std::string fSliceLabel;
  const float fRecombinationFactor;


  // Declare member data here.
  void FillMC(art::Ptr<simb::MCParticle>& mcp, std::vector<art::Ptr<simb::MCParticle>>& mctruthVect);
    // BackTrackerService
//    art::ServiceHandle<cheat::BackTrackerService> bt_serv;
};

sbnd::AnalyzeMichels::AnalyzeMichels(fhicl::ParameterSet const& p)
    : EDAnalyzer { p }, fMCMichelVect(nullptr), fRecoMichelVect(nullptr), fRecoMichelStartVect(nullptr), fMCMuonVect(nullptr), fRecoMuonVect(nullptr), fRecoMuonEndVect(nullptr)
    // Initialise out input labels by reading the fhicl parameters
    , fCalorimetryAlg(p.get<fhicl::ParameterSet>("CalorimetryAlg"))
    , fPFParticleLabel(p.get<std::string>("PFParticleLabel"))
   , fHitLabel(p.get<std::string>("HitLabel")) 
   , fTrackLabel(p.get<std::string>("TrackLabel"))
   , fShowerLabel(p.get<std::string>("ShowerLabel"))
    , fCaloLabel(p.get<std::string>("CalorimetryLabel"))
   , fMCTruthLabel(p.get<std::string>("MCTruthLabel"))
   , fClusterLabel(p.get<std::string>("ClusterLabel"))
   , fHitClusterLabel(p.get<std::string>("HitClusterLabel"))
  , fHitShowerLabel(p.get<std::string>("HitShowerLabel"))
  , fHitTrackLabel(p.get<std::string>("HitTrackLabel"))
  , fHitSpacePointLabel(p.get<std::string>("HitSpacePointLabel"))
  , fTrackCaloLabel(p.get<std::string>("TrackCaloLabel"))
  , sUseWPlaneOnly(p.get<int>("UseWPlaneOnly"))
  , fSliceLabel(p.get<std::string>("SliceLabel"))
  , fRecombinationFactor(p.get<float>("RecombinationFactor"))
{
  // Call appropriate consumes<>() for any products to be retrieved by this module.
}

void sbnd::AnalyzeMichels::rotateVector(TVector3 *vector) {
  float temp = vector->Y();
  vector->SetY(vector->Z());
  vector->SetZ(temp);
  temp = vector->X();
  vector->SetX(vector->Y());
  fMCMuonVect->SetY(temp);
}



void sbnd::AnalyzeMichels::analyze(art::Event const& e)
{
  // Implementation of required member function here.
  fEventID = e.id().event();

// std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";

  // Load the PFParticles from pandora
  art::Handle<std::vector<recob::PFParticle>> pfpHandle;
  std::vector<art::Ptr<recob::PFParticle>> pfpVec;
  if (e.getByLabel(fPFParticleLabel, pfpHandle))
    art::fill_ptr_vector(pfpVec, pfpHandle);

  // If there are no PFParticles then give up and skip the event
  if (pfpVec.empty())
    return;

   // Accessing hits
  art::Handle< std::vector<recob::Hit> > hitHandle;
  std::vector<art::Ptr <recob::Hit> > hitVect;
  if(e.getByLabel(fHitLabel, hitHandle))
    art::fill_ptr_vector(hitVect, hitHandle);

  fEventNHits = hitVect.size();

  // Access SpacePoints associated with each hit
  art::FindManyP<recob::SpacePoint> spacepointAssoc(hitVect, e, fHitSpacePointLabel);

  // Accessing slices
  art::Handle< std::vector<recob::Slice> > sliceHandle;
  std::vector<art::Ptr <recob::Slice> > sliceVect;
  if(e.getByLabel(fSliceLabel, sliceHandle))
    art::fill_ptr_vector(sliceVect, sliceHandle);

  fNSlices = sliceVect.size();

  // Selecting reco michel
  std::vector< art::Ptr<recob::Track> > michelTrack;
  std::vector< art::Ptr<recob::Shower> > michelShower;
  std::vector< art::Ptr<recob::Hit> > michelHitsNotRecod;

  // Select reco muon
  std::vector <art::Ptr<recob::Track> > muonTrack;

  // If no hits then skip event
  if (hitVect.empty())
    return;

  fNPFParticles = pfpVec.size();

  // Accessing MCParticles
  art::Handle< std::vector<simb::MCParticle> > mctruthHandle;
  std::vector< art::Ptr<simb::MCParticle> > mctruthVect;
  if(e.getByLabel(fMCTruthLabel, mctruthHandle))     // Make sure artHandle is from mo$
    art::fill_ptr_vector(mctruthVect, mctruthHandle);

  // Count other electrons produced by parent muon

  for (auto const &mcp: mctruthVect) {
    fMCPDG.push_back(mcp->PdgCode());
    fMCTrackID.push_back(mcp->TrackId());
  }
//std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
   
  // Get ID of Michel - always the last electron

  for(auto const &mcp: mctruthVect) {
    if(abs(mcp->PdgCode()) ==  13) {
      if((mcp->EndX()<200.) || abs(mcp->EndY()) < 200. || mcp->EndZ() < 0. || mcp->EndZ() > 500.) continue;
      ResetVars();
      FillMC(mcp, mctruthVect);
      FillRecoMuon();
    }
  }
  fMCMichelRelAngle = fMCMuonVect->Angle(*fMCMichelVect) * -180 / M_PI +180.0;

//std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
  // Setup clockData for use of RecoUtils
  auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService const>()->DataFor(e);
  auto const detProp = art::ServiceHandle<detinfo::DetectorPropertiesService const>()->DataFor(e, clockData);

  // Find clusters, tracks and showers associated to each PFParticle
  art::FindManyP<recob::Cluster> clusterAssoc(pfpVec, e, fClusterLabel);
  art::FindManyP<recob::Track> trackAssoc(pfpVec, e, fTrackLabel);
  art::FindManyP<recob::Shower> showerAssoc(pfpVec, e, fShowerLabel);

  // Accessing cluster objects in event
  art::Handle< std::vector<recob::Cluster> > clusterHandle;
  std::vector< art::Ptr<recob::Cluster> > clusterVect;
  if(e.getByLabel(fClusterLabel, clusterHandle))
    art::fill_ptr_vector(clusterVect, clusterHandle);


  // Find hits associated with clusters
  art::FindManyP<recob::Hit> hitAssoc(clusterVect, e, fHitClusterLabel);
  std::vector< art::Ptr<recob::Hit> > RecoMichelHits;
  std::vector< art::Ptr<recob::Hit> > RecoMuonHits;
  std::vector< art::Ptr<recob::SpacePoint> > RecoMichelSpacePoints;
  std::vector< art::Ptr<recob::SpacePoint> > RecoMuonSpacePoints;

  std::vector<float> ClusterHitMaxAm0;
  std::vector<float> ClusterhitSADC;
  for(const art::Ptr<recob::Cluster> &clust : clusterVect) {
    std::vector< art::Ptr<recob::Hit> > clusterHit = hitAssoc.at(clust.key());        
    fEventNClusterHits += clusterHit.size();
    for (const art::Ptr<recob::Hit> &hit : clusterHit) {
      ClusterHitMaxAm0.push_back(hit->PeakAmplitude());
      ClusterhitSADC.push_back(hit->SummedADC());
    }
  }

  for(const art::Ptr<recob::Hit> &hit : hitVect) {
    float hitSADC = hit->SummedADC();
    float hitMaxAmp = hit->PeakAmplitude();
    bool sadccheck = false;
    for(unsigned int hitnumber = 0; hitnumber < ClusterHitMaxAm0.size();hitnumber++) {
      if(hitSADC==ClusterhitSADC.at(hitnumber) && hitMaxAmp==ClusterHitMaxAm0.at(hitnumber)) sadccheck = true;
    }
    if(sadccheck) continue;
    fNonClustMaxAmp.push_back(hitMaxAmp);
    fNonClustSADC.push_back(hitSADC);
    if(RecoUtils::TrueParticleID(clockData, hit) == fMCMichelID) {
      fNonClustIsMichel.push_back(1);
      fNMichelNonClust++;
    } else {fNonClustIsMichel.push_back(0);
    }
    
    std::vector< art::Ptr<recob::SpacePoint> > hitPoints = spacepointAssoc.at(hit.key());
    for(const art::Ptr<recob::SpacePoint> &sp : hitPoints) {
      float x = sp->XYZ()[0];
      float y = sp->XYZ()[1];

      float z = sp->XYZ()[2];
      fNonClustX.push_back(x);
      fNonClustY.push_back(y);
      fNonClustZ.push_back(z);
      TVector3 spPos;
      spPos.SetXYZ(x, y, z);
      TVector3 mcmichelstart;
      mcmichelstart.SetXYZ(fMCMichelStartX, fMCMichelStartY, fMCMichelStartZ);
      fNonClustDist.push_back((spPos - mcmichelstart).Mag());       
    }
  }


  int hitno;
  int NTrueHitsInRecoMichel;
  int NPFPs = 0;
  for(const art::Ptr<recob::PFParticle> &pfp : pfpVec){         // Loop over PFPs in event
    if(pfp->PdgCode()==11) fNRecoElectrons++;
    if(pfp->PdgCode()==13) fNMuons++;
  NPFPs++;
  }

  int fRecoMuonHitsInRecoMuon = 0;
  float maxadc = 0;
  float maxamp = 0;

  for(const art::Ptr<recob::PFParticle> &pfp : pfpVec){     	// Loop over PFPs in event
    float curdist = 1000.0;
    float mindist = 500.0;
    TVector3 current_sp;
    TVector3 last_sp;
    last_sp.SetXYZ(1600.1, 1000.1, 1000.1);
    hitno = 0;
    NTrueHitsInRecoMichel = 0;
    std::vector< art::Ptr<recob::Hit> > hitsFromPFPVect;
    int pdg = pfp->PdgCode();
    int NTrueHitsInPFP = 0;
    int NMuonHitsInPFP = 0;
    std::vector< art::Ptr<recob::Cluster> > pfpCluster = clusterAssoc.at(pfp.key());  
    fNClusters.push_back(pfpCluster.size());
    int NClusters = 0;
    fPFParticlePDG.push_back(pfp->PdgCode());
    if(pfpCluster.empty()) continue;
    for(const art::Ptr<recob::Cluster> &clust : pfpCluster){     // For each cluster
      std::vector< art::Ptr<recob::Hit> > clusterHits = hitAssoc.at(clust.key());
      if(clusterHits.empty()) continue;
      std::string clusterplane = clust->Plane().toString();
      lastchar = clusterplane.back();
      if(sUseWPlaneOnly==1) {
        if(lastchar=="2") {
          hitsFromPFPVect.insert(hitsFromPFPVect.end(), clusterHits.begin(), clusterHits.end());  
          fClusterID.push_back(clust->ID());
          fClusterPlane.push_back(lastchar);
          NClusters++;
        }
      } else {
          hitsFromPFPVect.insert(hitsFromPFPVect.end(), clusterHits.begin(), clusterHits.end());
          fClusterID.push_back(clust->ID());
          fClusterPlane.push_back(lastchar);
          NClusters++;        
      }
    }
    for (const art::Ptr<recob::Hit> &hit : hitsFromPFPVect) {		// Loop over individual hits in each PFP
      hitno++;
      std::vector< art::Ptr<recob::SpacePoint> > hitPoints = spacepointAssoc.at(hit.key());
      if(hitPoints.empty()) continue;

      int hitid = RecoUtils::TrueParticleID(clockData, hit);
      if(hitid==fMCMichelID) {
        NTrueHitsInPFP++;
        fNTotalMichelHits++;
      }
      if(hitid==1) NMuonHitsInPFP++;			// Reco Muon normally found on second run of PFP for loop 
      if(hit->SummedADC() > maxadc && !hitPoints.empty()){
        maxadc = hit->SummedADC();
        for (const art::Ptr<recob::SpacePoint> &spacepoint : hitPoints) {
          fMaxSADCX = spacepoint->XYZ()[0];
          fMaxSADCY = spacepoint->XYZ()[1];
          fMaxSADCZ = spacepoint->XYZ()[2];
        }
      }
      if(hit->PeakAmplitude() > maxamp && !hitPoints.empty()){
        maxamp = hit->PeakAmplitude();
        for (const art::Ptr<recob::SpacePoint> &spacepoint : hitPoints) {
          fMaxAmpX = spacepoint->XYZ()[0];
          fMaxAmpY = spacepoint->XYZ()[1];
          fMaxAmpZ = spacepoint->XYZ()[2];
        }
      }
      if(!hitPoints.empty()) {
        for (const art::Ptr<recob::SpacePoint> &spacepoint : hitPoints) {
          current_sp.SetXYZ(spacepoint->XYZ()[0], spacepoint->XYZ()[1], spacepoint->XYZ()[2]);
      }  
      curdist = (current_sp - last_sp).Mag();
        if(curdist < mindist) mindist = curdist;
        last_sp = current_sp;
      }
    }
      
    if(NTrueHitsInPFP > fNTrueHitsInRecoMichel) {			// Always favour michels reco'd as ele
      RecoMichelHits = hitsFromPFPVect;
      NTrueHitsInRecoMichel = NTrueHitsInPFP;
      fNTrueHitsInRecoMichel = NTrueHitsInRecoMichel;  
      fNHitsInRecoMichel = RecoMichelHits.size();
      fNRecoMichelSpacePoints = RecoMichelSpacePoints.size();
     fRecoMichelID = pfp->Self();
     fRecoMichel = true;
      fRecoMichelMother = pfp->Parent();
      fRecoMichelNClusters = NClusters;
      fRecoMuonID = fRecoMichelMother;
      michelTrack.clear();
      michelTrack = trackAssoc.at(pfp.key());
      michelShower.clear();
      michelShower = showerAssoc.at(pfp.key());
        fRecoMichelCloseProximity = mindist;
    }
    //std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
    if(NMuonHitsInPFP > fRecoMuonHitsInRecoMuon) {
      fNRecoMuonHits = NMuonHitsInPFP;
      RecoMuonHits = hitsFromPFPVect;
      fRecoMuonNClusters = NClusters;
      fNTrueHitsInRecoMuon = NTrueHitsInPFP;
      muonTrack = trackAssoc.at(pfp.key());
      fRecoMuonHitsInRecoMuon = NMuonHitsInPFP;
    }
    fNHitsInPFP.push_back(hitno);
    fNTrueHitsInPFP.push_back(NTrueHitsInPFP);
    fRecoMuonIsPrimary = pfp->IsPrimary();
    fRecoMuonMother = pfp->Parent();
    fPFPIsPrimary.push_back(pfp->IsPrimary());
    fPFPMother.push_back(pfp->Parent());
    if(pdg==11&&NTrueHitsInPFP>0) fNElectronsWithTrueHits++;
      else {
        if(pdg==13&&NTrueHitsInPFP>0) fNMuonsWithTrueHits++;
      }
  }


  if(fNHitsInRecoMichel > 0) {
    fPurity = float(fNTrueHitsInRecoMichel) / float(fNHitsInRecoMichel);
    fCompleteness = float(fNTrueHitsInRecoMichel) / float(fNTotalMichelHits);
  }  



// Analyse reco muon

  if(!muonTrack.empty()) {
  // Find hits associated with tracks
    art::Handle< std::vector<recob::Track> > trackHandle;
    std::vector< art::Ptr<recob::Track> > trackVect;
    if(e.getByLabel(fTrackLabel, trackHandle))
      art::fill_ptr_vector(trackVect, trackHandle);

     art::FindManyP<recob::Hit> hitTrackAssoc(trackVect, e, fHitTrackLabel);

    art::FindManyP<anab::Calorimetry> caloTrackAssoc(trackVect, e, fTrackCaloLabel);

    fNTracks = michelTrack.size();
    for(const art::Ptr<recob::Track> &track : muonTrack){
      TVector3 trackdir;
      fRecoMuonPhi = track->AzimuthAngle() * 180 / M_PI;
      fRecoMuonTheta = track->ZenithAngle() * 180 / M_PI - 90.0;
      fRecoMuonEndX = track->End().X();
      fRecoMuonEndY = track->End().Y();
      fRecoMuonEndZ = track->End().Z();
//      fRecoMuonEndVect.SetX(track->EndDirection().X());
//      fRecoMuonEndVect.SetY(track->EndDirection().Y());
//      fRecoMuonEndVect.SetZ(track->EndDirection().Z());
//      fRecoMuonEndVect.Unit();


    // Get cluster assocs with track
    // Get hit assoc with cluster
    // Get n hits in each plane
    // Get spacepoints assoc with hits
    // Find linearity of last 8 muon points in W plane

      std::vector< art::Ptr<recob::Hit> > trackHits = hitTrackAssoc.at(track.key());    // find associated hits
      std::vector<art::Ptr <recob::Hit> > muonhits_u;
      std::vector<art::Ptr <recob::Hit> > muonhits_v;
      std::vector<art::Ptr <recob::Hit> > muonhits_w;
      int nhits_u = 0;
      int nhits_v = 0;
      int nhits_w = 0;
      for(art::Ptr<recob::Hit> &hit : trackHits){ 
        if(hit->View()==0) {
          nhits_u++;
          muonhits_u.push_back(hit);
        }
        if(hit->View()==1) {
          nhits_v++;
          muonhits_v.push_back(hit);
        }
        if(hit->View()==2) {
          nhits_w++;
          muonhits_w.push_back(hit);
        }
      }
      unsigned int iteration = 0;
      std::vector<float> muon_linearity;
      TVector3 cur_vect = {0.0, 0.0, 0.0};
      TVector3 prev_vect = {0.0, 0.0, 0.0};
      TVector3 cur_dir = {0.0, 0.0, 0.0};
      TVector3 prev_dir = {0.0, 0.0, 0.0};
      for(art::Ptr<recob::Hit> &hit : muonhits_w) {
        iteration++;
        if(iteration < muonhits_w.size() - 8) continue;
        std::vector< art::Ptr<recob::SpacePoint> > spacepoint = spacepointAssoc.at(hit.key());
        if(spacepoint.empty()) continue;
        for(const art::Ptr<recob::SpacePoint> &sp : spacepoint) {
          if(prev_vect.X() == 0.0) {
            prev_vect.SetXYZ(sp->XYZ()[0], sp->XYZ()[1], sp->XYZ()[2]);
            continue;
          }
          cur_vect.SetXYZ(sp->XYZ()[0], sp->XYZ()[1], sp->XYZ()[2]);
          if(prev_dir.X() == 0.0) {
            prev_dir = (cur_vect - prev_vect).Unit();
            continue;
          }  
          cur_dir = (cur_vect - prev_vect).Unit();
          muon_linearity.push_back(prev_dir.Dot(cur_dir));
          prev_vect = cur_vect;
          prev_dir = cur_dir;
        }
      }
      float sum = 0.0;
      for(float lin : muon_linearity) sum += lin;
      fRecoMuonEndBendinessVect[2] = sum/ muon_linearity.size();
      fRecoMuonNHitsPlane = {nhits_u, nhits_v, nhits_w};
    }
    
  }
//std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
  fNTracks = michelTrack.size();
  fNShowers = michelShower.size();

  std::vector< art::Ptr<recob::Hit> > RecoMichelHitsU;
  std::vector< art::Ptr<recob::Hit> > RecoMichelHitsV;
  std::vector< art::Ptr<recob::Hit> > RecoMichelHitsW;

  if(!michelShower.empty()) {
    fIsShower = true;
  // Find hits associated with shower
    art::Handle< std::vector<recob::Shower> > showerHandle;
    std::vector< art::Ptr<recob::Shower> > showerVect;
    if(e.getByLabel(fShowerLabel, showerHandle))
      art::fill_ptr_vector(showerVect, showerHandle);
    
    art::FindManyP<recob::Hit> hitShowerAssoc(showerVect, e, fHitShowerLabel);

    fNShowers = michelShower.size();
    for(const art::Ptr<recob::Shower> &shower : michelShower){

      TVector3 shwstart = shower->ShowerStart();
      fRecoMichelStartX = shwstart.X();
      fRecoMichelStartY = shwstart.Y();
      fRecoMichelStartZ = shwstart.Z();
      fRecoMichelLength = shower->Length();
      fShowerBestPlane = shower->best_plane();
      std::vector<float> recomichelstartvect = {1.0, 1.0, 1.0};
//      recomichelstartvect[0] = shower->Direction().X();
//      recomichelstartvect[1] = shower->Direction().Y();
//      recomichelstartvect[2] = shower->Direction().Z();
      fRecoMichelStartVect->SetXYZ(recomichelstartvect[0], recomichelstartvect[1], recomichelstartvect[2]);
//      fRecoMichelStartVect.Unit();
//      fRecoMichelRelAngle = fRecoMuonEndVect->Angle(&fRecoMichelStartVect) * 180.0 / M_PI;
      int ShowerBestPlane = fShowerBestPlane;
      if(sUseWPlaneOnly==1) ShowerBestPlane = 2;
      fRecoMichelEnergy = shower->Energy().at(ShowerBestPlane);
      TVector3 showerdir = shower->Direction();
      rotateVector(&showerdir);
      fRecoMichelTheta = showerdir.Theta() * 180 / M_PI + 90.0;
      rotateVector(&showerdir);
      fRecoMichelPhi = showerdir.Theta() * 180 / M_PI + 90.0;
      fRecoMichelEnergySigma = shower->EnergyErr().at(ShowerBestPlane);
      fRecoMicheldEdX = shower->dEdx();
      fRecoMichelEnergyVect[0] = shower->Energy().at(0);
      fRecoMichelEnergyVect[1] = shower->Energy().at(1);
      fRecoMichelEnergyVect[2] = shower->Energy().at(2);
      if(fRecoMichelEnergyVect[0] > 0) fRecoMichelEnergyDiffVect[0] = fRecoMichelEnergyVect[0] - fMCMichelEnergy;
      if(fRecoMichelEnergyVect[1] > 0) fRecoMichelEnergyDiffVect[1] = fRecoMichelEnergyVect[1] - fMCMichelEnergy;
      if(fRecoMichelEnergyVect[2] > 0) fRecoMichelEnergyDiffVect[2] = fRecoMichelEnergyVect[2] - fMCMichelEnergy;
      
      std::vector< art::Ptr<recob::Hit> > showerHits = hitShowerAssoc.at(shower.key());    // find associated hits
      float n_true_hits_u = 0;
      float n_true_hits_v = 0;
      float n_true_hits_w = 0;
      float n_hits_u = 0;
      float n_hits_v = 0;
      float n_hits_w = 0;
      float n_electrons_u = 0;
      float n_electrons_v = 0;
      float n_electrons_w = 0;
      float n_true_electrons_u = 0;
      float n_true_electrons_v = 0;
       float n_true_electrons_w = 0;
      float integral_sum_u = 0;
      float true_integral_sum_u = 0;
      float integral_sum_v = 0;
      float true_integral_sum_v = 0;
      float integral_sum_w = 0;
      float true_integral_sum_w = 0;
      float total_true_electrons = 0;
      float total_electrons = 0;
      for(art::Ptr<recob::Hit> &hit : showerHits){
        fRecoMichelHitIntegral.push_back(hit->Integral());
        fRecoMichelHitPeakTime.push_back(hit->PeakTime());
        fRecoMichelhitMultiplicity.push_back(hit->Multiplicity());
        fRecoMichelHitGOF.push_back(hit->GoodnessOfFit());
        if(hit->View()== 0) {
          n_hits_u++;
        integral_sum_u += hit->Integral() * fCalorimetryAlg.LifetimeCorrection(clockData, detProp, hit->PeakTime());
          if(RecoUtils::TrueParticleID(clockData, hit) == fMCMichelID) {
            n_true_hits_u++;
            true_integral_sum_u += hit->Integral() * fCalorimetryAlg.LifetimeCorrection(clockData, detProp, hit->PeakTime());
          }
        }
        if(hit->View()== 1) {
          n_hits_v++;
          integral_sum_v += hit->Integral() * fCalorimetryAlg.LifetimeCorrection(clockData, detProp, hit->PeakTime());
          if(RecoUtils::TrueParticleID(clockData, hit) == fMCMichelID) {
            n_true_hits_v++;
            true_integral_sum_v += hit->Integral() * fCalorimetryAlg.LifetimeCorrection(clockData, detProp, hit->PeakTime());
          }
        }
        if(hit->View()== 2) {
          n_hits_w++;
          integral_sum_w += hit->Integral() * fCalorimetryAlg.LifetimeCorrection(clockData, detProp, hit->PeakTime());
          if(RecoUtils::TrueParticleID(clockData, hit) == fMCMichelID) {
            n_true_hits_w++;
            true_integral_sum_w += hit->Integral() * fCalorimetryAlg.LifetimeCorrection(clockData, detProp, hit->PeakTime());
          }
        }
//        fRecoMichelNElectrons.push_back(
//          fCalorimetryAlg.LifetimeCorrection(
//              clockData, detProp, hit->PeakTime()
//            )
//        );
        fRecoMichelHitPlane.push_back(hit->View());
      }
      if(!showerHits.empty()) {
        int michelHitsInShower = 0;
        for(art::Ptr<recob::Hit> &hit : showerHits){
          if(RecoUtils::TrueParticleID(clockData, hit) == fMCMichelID) michelHitsInShower++;
        }
      fShowerPurity = michelHitsInShower / (double)showerHits.size();
      }
    if(n_hits_u > 0) {
     fRecoMichelPurityVect[0] = n_true_hits_u / n_hits_u;
      integral_sum_u /= fRecombinationFactor;
      true_integral_sum_u /= fRecombinationFactor;      
    n_electrons_u = fCalorimetryAlg.ElectronsFromADCArea(integral_sum_u, 0);
    n_true_electrons_u = fCalorimetryAlg.ElectronsFromADCArea(true_integral_sum_u, 0);
    fRecoMichelEPurityU =  n_true_electrons_u / n_electrons_u;
    fRecoMichelEPurityVect[0] = n_true_electrons_u / n_electrons_u;
    total_true_electrons += n_true_electrons_u;
    total_electrons += n_electrons_u;
    }
    if(n_hits_v > 0) {
      fRecoMichelPurityVect[1] = n_true_hits_v / n_hits_v;
      integral_sum_v /= fRecombinationFactor;
      true_integral_sum_v /= fRecombinationFactor;
    n_electrons_v = fCalorimetryAlg.ElectronsFromADCArea(integral_sum_v, 1);
    n_true_electrons_v = fCalorimetryAlg.ElectronsFromADCArea(true_integral_sum_v, 1);
    fRecoMichelEPurityV =  n_true_electrons_v / n_electrons_v;
    fRecoMichelEPurityVect[1] = n_true_electrons_v / n_electrons_v;
    total_true_electrons += n_true_electrons_v;
    total_electrons += n_electrons_v;
    }
    if(n_hits_w > 0) {
      fRecoMichelPurityVect[2] = n_true_hits_w / n_hits_w;
      integral_sum_w /= fRecombinationFactor;
      true_integral_sum_w /= fRecombinationFactor;
      n_electrons_w = fCalorimetryAlg.ElectronsFromADCArea(integral_sum_w, 2);
      n_true_electrons_w = fCalorimetryAlg.ElectronsFromADCArea(true_integral_sum_w, 2);
      fRecoMichelEPurityW =  n_true_electrons_w / n_electrons_w;
      fRecoMichelEPurityVect[2] = n_true_electrons_w / n_electrons_w;
      total_true_electrons += n_true_electrons_w;
      total_electrons += n_electrons_w;
    }
    fRecoMichelEPurity = total_true_electrons / total_electrons;
    fRecoMichelNHitsPlane = {int(n_hits_u), int(n_hits_v), int(n_hits_w)};
    }
  }
// std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
  if(!michelTrack.empty()) {
    fIsTrack = true;
  // Find hits associated with tracks
    art::Handle< std::vector<recob::Track> > trackHandle;
    std::vector< art::Ptr<recob::Track> > trackVect;
    if(e.getByLabel(fTrackLabel, trackHandle))
      art::fill_ptr_vector(trackVect, trackHandle);

     art::FindManyP<recob::Hit> hitTrackAssoc(trackVect, e, fHitTrackLabel);

    art::FindManyP<anab::Calorimetry> caloTrackAssoc(trackVect, e, fTrackCaloLabel);

    fNTracks = michelTrack.size();
    for(const art::Ptr<recob::Track> &track : michelTrack){
      TVector3 trackdir;
      fRecoMichelPhi = track->AzimuthAngle() * 180 / M_PI;
      fRecoMichelTheta = track->ZenithAngle() * 180 / M_PI - 90;


//     fShowerBestPlane = shower->best_plane();
      std::vector<art::Ptr<anab::Calorimetry> >trackCalo = caloTrackAssoc.at(track.key());
      if(!trackCalo.empty()) {
        for(art::Ptr<anab::Calorimetry> &calo : trackCalo) {
          fRecoMichelEnergy = calo->KineticEnergy();
        }
      }
    }
  }

  std::vector<float> showerintegrals_u;
  std::vector<float> showerintegrals_v;
  std::vector<float> showerintegrals_w;
  std::vector<float> showermults_u;
  std::vector<float> showermults_v;
  std::vector<float> showermults_w;
  std::vector<float> showergofs_u;
  std::vector<float> showergofs_v;
  std::vector<float> showergofs_w;
  for(unsigned int num = 0;num<fRecoMichelHitIntegral.size();num++) {
    if(fRecoMichelHitPlane.at(num)==0) {
      showerintegrals_u.push_back(fRecoMichelHitIntegral.at(num));
      showermults_u.push_back(fRecoMichelhitMultiplicity.at(num));
      showergofs_u.push_back(fRecoMichelHitGOF.at(num));
    }
    if(fRecoMichelHitPlane.at(num)==1) {
      showerintegrals_v.push_back(fRecoMichelHitIntegral.at(num));
      showermults_v.push_back(fRecoMichelhitMultiplicity.at(num));
      showergofs_v.push_back(fRecoMichelHitGOF.at(num));
    }
    if(fRecoMichelHitPlane.at(num)==2) {
      showerintegrals_w.push_back(fRecoMichelHitIntegral.at(num));
      showermults_w.push_back(fRecoMichelhitMultiplicity.at(num));
      showergofs_w.push_back(fRecoMichelHitGOF.at(num));
    }
  }

  if(!showerintegrals_u.empty()) {
    float max_int = 0;
    float sum_int  = 0.0;
    float max_gof = 0.0;
    float sum_gof = 0.0;
    float max_mult = 0.0;
    float sum_mult = 0.0;
    for(unsigned int i=0;i<showerintegrals_u.size() ;i++) {
      sum_int += showerintegrals_u.at(i);
      sum_gof += showergofs_u.at(i);
      sum_mult += showermults_u.at(i);
      if(showerintegrals_u.at(i) > max_int) max_int = showerintegrals_u.at(i);
      if(showergofs_u.at(i) > max_gof) max_gof = showergofs_u.at(i);
      if(showermults_u.at(i) > max_mult) max_mult = showermults_u.at(i);
    }
    fRecoMichelIntegralMaxVect[0] = max_int;
    fRecoMichelGOFMaxVect[0] = max_gof;
    fRecoMichelMultMaxVect[0] = max_mult;
    fRecoMichelIntegralMeanVect[0] = sum_int / showerintegrals_u.size();
    fRecoMichelGOFMeanVect[0] = sum_gof / showergofs_u.size();
    fRecoMichelMultMeanVect[0] = sum_mult / showermults_u.size();
    float accum_int = 0.0;
    float accum_gof = 0.0;
    float accum_mult = 0.0;
    for(unsigned int i=0; i<showerintegrals_u.size();i++) {
      accum_int += (showerintegrals_u.at(i) - fRecoMichelIntegralMeanU) * (showerintegrals_u.at(i) - fRecoMichelIntegralMeanU);
      accum_gof += (showergofs_u.at(i) - fRecoMichelGOFMeanU) * (showergofs_u.at(i) - fRecoMichelGOFMeanU);
      accum_mult += (showermults_u.at(i) - fRecoMichelMultiplicityMeanU) * (showermults_u.at(i) - fRecoMichelMultiplicityMeanU);
    }
    fRecoMichelIntegralSigmaVect[0] = sqrt(accum_int / (showerintegrals_u.size()));
    fRecoMichelGOFSigmaVect[0] = sqrt(accum_gof / (showerintegrals_u.size()));
    fRecoMichelMultSigmaVect[0] = sqrt(accum_mult / (showerintegrals_u.size()));
  }

  if(!showerintegrals_u.empty()) {
    float max_int = 0;
    float sum_int  = 0.0;
    float max_gof = 0;
    float sum_gof = 0.0;
    float max_mult = 0.0;
    float sum_mult = 0.0;
    for(unsigned int i=0;i<showerintegrals_v.size();i++) {
      sum_int += showerintegrals_v.at(i);
      sum_gof += showergofs_v.at(i);
      sum_mult += showermults_v.at(i);
      if(showerintegrals_v.at(i) > max_int) max_int = showerintegrals_v.at(i);
      if(showergofs_v.at(i) > max_gof) max_gof = showergofs_v.at(i);
      if(showermults_v.at(i) > max_mult) max_mult = showermults_v.at(i);
    }
    fRecoMichelIntegralMaxVect[1] = max_int;
    fRecoMichelGOFMaxVect[1] = max_gof;
    fRecoMichelMultMaxVect[1] = max_mult;
    fRecoMichelIntegralMeanVect[1] = sum_int / showerintegrals_v.size();
    fRecoMichelGOFMeanVect[1] = sum_gof / showergofs_v.size();
    fRecoMichelMultMeanVect[1] = sum_mult / showermults_v.size();
    double accum_int = 0.0;
    float accum_gof = 0.0;
    float accum_mult = 0.0;
    for(unsigned int i=0; i<showerintegrals_v.size(); i++) {
      accum_int += (showerintegrals_v.at(i) - fRecoMichelIntegralMeanV) * (showerintegrals_v.at(i) - fRecoMichelIntegralMeanV);
      accum_gof += (showergofs_v.at(i) - fRecoMichelGOFMeanV) * (showergofs_v.at(i) - fRecoMichelGOFMeanV);
      accum_mult += (showermults_v.at(i) - fRecoMichelMultiplicityMeanV) * (showermults_v.at(i) - fRecoMichelMultiplicityMeanV);
    }
    fRecoMichelIntegralSigmaVect[1] = sqrt(accum_int / (showerintegrals_v.size()));
     fRecoMichelGOFSigmaVect[1] = sqrt(accum_gof / (showerintegrals_v.size()));
    fRecoMichelMultSigmaVect[1] = sqrt(accum_mult / (showerintegrals_v.size()));
  }

  if(!showerintegrals_w.empty()) {
    float max_int = 0;
    float sum_int  = 0.0;
    float max_gof = 0;
    float sum_gof = 0.0;
    float max_mult = 0.0;
    float sum_mult = 0.0;
    for(unsigned int i=0;i < showerintegrals_w.size();i++) {
      sum_int += showerintegrals_w.at(i);
      sum_gof += showergofs_w.at(i);
      sum_mult += showermults_w.at(i);
      if(showerintegrals_w.at(i) > max_int) max_int = showerintegrals_w.at(i);
      if(showergofs_w.at(i) > max_gof) max_gof = showergofs_w.at(i);
      if(showermults_w.at(i) > max_mult) max_mult = showermults_w.at(i);
    }
    fRecoMichelIntegralMaxVect[2] = max_int;
    fRecoMichelGOFMaxVect[2] = max_gof;
    fRecoMichelMultMaxVect[2] = max_mult;
    fRecoMichelIntegralMeanVect[2] = sum_int / showerintegrals_w.size();
    fRecoMichelGOFMeanVect[2] = sum_gof / showergofs_w.size();
    fRecoMichelMultMeanVect[2] = sum_mult / showermults_w.size();
    double accum_int = 0.0;
    float accum_gof = 0.0;
    float accum_mult = 0.0;
    for(unsigned int i=0; i<showerintegrals_w.size(); i++) {
      accum_int += (showerintegrals_w.at(i) - fRecoMichelIntegralMeanW) * (showerintegrals_w.at(i) - fRecoMichelIntegralMeanW);
      accum_gof += (showergofs_w.at(i) - fRecoMichelGOFMeanW) * (showergofs_w.at(i) - fRecoMichelGOFMeanW);
      accum_mult += (showermults_w.at(i) - fRecoMichelMultiplicityMeanW) * (showermults_w.at(i) - fRecoMichelMultiplicityMeanW);
    }
    fRecoMichelIntegralSigmaVect[2] = sqrt(accum_int / (showerintegrals_w.size()));
    fRecoMichelGOFSigmaVect[2] = sqrt(accum_gof / (showerintegrals_w.size()));
    fRecoMichelMultSigmaVect[2] = sqrt(accum_mult / (showerintegrals_w.size()));
  }

//std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
  // Store the outputs in the TTree
TVector3 recomuonendvect;
  recomuonendvect.SetXYZ(fRecoMuonEndX, fRecoMuonEndY, fRecoMuonEndZ);

  std::vector<float> sh_ediff;
  std::vector<float>  sh_mult;
  std::vector<float> sh_gof;
  unsigned int min_mult, min_gof;
  float min_gof_e = 100000.0;
  float min_mult_e = 100000.0;
  float min_e = 100000.0;
  sh_ediff = fRecoMichelEnergyDiffVect;
  sh_mult.push_back(fRecoMichelMultiplicityMeanU);
  sh_mult.push_back(fRecoMichelMultiplicityMeanV);
   sh_mult.push_back(fRecoMichelMultiplicityMaxW);
  sh_gof.push_back(fRecoMichelGOFMeanU); 
  sh_gof.push_back(fRecoMichelGOFMeanV);
  sh_gof.push_back(fRecoMichelGOFMeanW);
  
  for(unsigned int i=0;i<3;i++) {
    bool neg;
    neg = false;
    if(sh_ediff.at(i) < 0) {
      neg = true;
      sh_ediff.at(i) *= -1;
    }   
    if(sh_ediff.at(i) < min_e && sh_ediff.at(i) != 0) {
      min_e = sh_ediff.at(i);
      if(neg) sh_ediff.at(i) *= -1;
    }
    if(sh_gof.at(i) < min_gof_e && sh_gof.at(i) != 0) {
      min_gof = i;
      min_gof_e = sh_gof.at(i);
    }
  if(sh_mult.at(i) < min_mult_e && sh_mult.at(i) != 0) {
      min_mult = i;
      min_mult_e = sh_mult.at(i);
    }
  }

  fRecoMichelEDiffMinMult = sh_ediff.at(min_mult);
  fRecoMichelEDiffMinGOF = sh_ediff.at(min_gof);

  TVector3 maxampvect;
  maxampvect.SetXYZ(fMaxAmpX, fMaxAmpY, fMaxAmpZ);
  fMaxAmpDist = (maxampvect - recomuonendvect).Mag();
  TVector3 maxsadcvect;
  maxsadcvect.SetXYZ(fMaxSADCX, fMaxSADCY, fMaxSADCZ);
  fMaxSADCDist = (maxsadcvect - recomuonendvect).Mag();

  fTree->Fill();
//std::cout << __FILE__ << "::" << __func__ << "():[" << __LINE__ << "]\t\n";
}

void sbnd::AnalyzeMichels::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;

  // Get the TFileService to create out output tree for us
  fTree = tfs->make<TTree>("tree", "Output Tree");

  // Add branches to the TTree
  // Event
  fTree->Branch("event.ID", 			&fEventID);
  fTree->Branch("event.NPFParticles", 		&fNPFParticles);
  fTree->Branch("event.PFParticlePDG", 		&fPFParticlePDG);
  fTree->Branch("event.NHits", 			&fEventNHits);
  fTree->Branch("event.NClusterHits",		&fEventNClusterHits);
  fTree->Branch("event.MCPDG", 			&fMCPDG);
  fTree->Branch("event.MCTrackID", 		&fMCTrackID);
  fTree->Branch("event.PFPNHits", 		&fNHitsInPFP);
  fTree->Branch("event.PFPNTrueHits", 		&fNTrueHitsInPFP);
  fTree->Branch("event.PFPNCluster", 		&fNClusters);
  fTree->Branch("event.NRecoElectrons",		&fNRecoElectrons);
  fTree->Branch("event.WrongRecoMuonEnd",	&fWrongMuonEnd);
  fTree->Branch("event.ClusterID",		&fClusterID);
  fTree->Branch("event.ClusterPlane",		&fClusterPlane);
  fTree->Branch("event.NRecoMuons",		&fNMuons);
  fTree->Branch("event.RecoMuonMichelDist",	&fRecoMuonMichelDist);
  fTree->Branch("event.PFPIsPrimary",		&fPFPIsPrimary);
  fTree->Branch("event.PFPMother",		&fPFPMother);
  fTree->Branch("event.NElectronsWithTrueHits",	&fNElectronsWithTrueHits);
  fTree->Branch("event.NMuonsWithTrueHits",	&fNMuonsWithTrueHits);
  fTree->Branch("event.MaxSADCX",		&fMaxSADCX);
  fTree->Branch("event.MaxSADCY",               &fMaxSADCY);
  fTree->Branch("event.MaxSADCZ",		&fMaxSADCZ);
  fTree->Branch("event.MaxSADCDist",               &fMaxSADCDist);
  fTree->Branch("event.MaxAmpX",               &fMaxAmpX);
  fTree->Branch("event.MaxAmpY",               &fMaxAmpY);
  fTree->Branch("event.MaxAmpZ",               &fMaxAmpZ);
  fTree->Branch("event.MaxAmpDist",            	&fMaxAmpDist);
  fTree->Branch("event.AmpMean",		&fAmpMean);
  fTree->Branch("event.AmpSigma",		&fAmpSigma);
  fTree->Branch("event.SADCMean",		&fSADCMean);
  fTree->Branch("event.SADCSigma",		&fSADCSigma);
  fTree->Branch("event.NSlices",		&fNSlices);
  fTree->Branch("event.NNonclustMichelHits",	&fNMichelNonClust);

  // MC Michel
  fTree->Branch("mcMichel.ID", 			&fMCMichelID);
  fTree->Branch("mcMichel.Energy", 		&fMCMichelEnergy);
  fTree->Branch("mcMichel.Theta", 		&fMCMichelTheta);
  fTree->Branch("mcMichel.Phi", 		&fMCMichelPhi);
  fTree->Branch("mcMichel.RelTheta", 		&fMCMichelRelTheta);
  fTree->Branch("mcMichel.RelPhi", 		&fMCMichelRelPhi);
  fTree->Branch("mcMichel.Vect", 		&fMCMichelVect);
  fTree->Branch("mcMichel.Length", 		&fMCMichelLength);
  fTree->Branch("mcMichel.StartX",		&fMCMichelStartX);
  fTree->Branch("mcMichel.StartY",		&fMCMichelStartY);
  fTree->Branch("mcMichel.StartZ",		&fMCMichelStartZ);
  fTree->Branch("mcMichel.RelAngle",		&fMCMichelRelAngle);
  fTree->Branch("mcMichel.NPoints",		&fMCMichelNPoints);
  fTree->Branch("mcMichel.EnergyFrac",		&fMCMichelEnergyFrac);

  // Reco Michel
  fTree->Branch("recoMichel.Purity", 		&fPurity);
  fTree->Branch("recoMichel.Completeness", 	&fCompleteness);
  fTree->Branch("recoMichel.NHits", 		&fNHitsInRecoMichel);
  fTree->Branch("recoMichel.TotalHits", 	&fNTotalMichelHits);
  fTree->Branch("recoMichel.NShowers", 		&fNShowers);
  fTree->Branch("recoMichel.NTracks", 		&fNTracks);
  fTree->Branch("recoMichel.Exists", 		&fRecoMichel);
  fTree->Branch("recoMichel.ShowerPurity", 	&fShowerPurity);
  fTree->Branch("recoMichel.TrackPurity", 	&fTrackPurity);
  fTree->Branch("recoMichel.ShowerBestPlane", 	&fShowerBestPlane);
  fTree->Branch("recoMichel.IsTrack", 		&fIsTrack);
  fTree->Branch("recoMichel.IsShower", 		&fIsShower);
  fTree->Branch("recoMichel.NTrueHits", 	&fNTrueHitsInRecoMichel);
  fTree->Branch("recoMichel.Energy", 		&fRecoMichelEnergy);
  fTree->Branch("recoMichel.Theta", 		&fRecoMichelTheta);
  fTree->Branch("recoMichel.Phi", 		&fRecoMichelPhi);
  fTree->Branch("recoMichel.RelTheta", 		&fRecoMichelRelTheta);
  fTree->Branch("recoMichel.RelPhi", 		&fRecoMichelRelPhi);
  fTree->Branch("recoMichel.RelAngle",		&fRecoMichelRelAngle);
  fTree->Branch("recoMichel.Vect", 		&fRecoMichelVect);
  fTree->Branch("recoMichel.StartX",		&fRecoMichelStartX);
  fTree->Branch("recoMichel.StartY",		&fRecoMichelStartY);
  fTree->Branch("recoMichel.StartZ",		&fRecoMichelStartZ);
  fTree->Branch("recoMichel.ID", 		&fRecoMichelID);
  fTree->Branch("recoMichel.Mother",		&fRecoMichelMother);
  fTree->Branch("recoMichel.NSpacePoints",	&fNRecoMichelSpacePoints);
  fTree->Branch("recoMichel.Length",		&fRecoMichelLength);
  fTree->Branch("recoMichel.Azimuth",		&fRecoMichelAzi);
  fTree->Branch("recoMichel.Zenith",		&fRecoMichelZen);
  fTree->Branch("recoMichel.ClosestHitDist",	&fRecoMichelCloseProximity);
  fTree->Branch("recoMichel.NClusters",		&fRecoMichelNClusters);
  fTree->Branch("recoMichel.EnergySigma",	&fRecoMichelEnergySigma);
  fTree->Branch("recoMichel.dEdX",		&fRecoMicheldEdX);
  fTree->Branch("recoMichel.HitIntegral",	&fRecoMichelHitIntegral);
  fTree->Branch("recoMichel.HitPeakTime",	&fRecoMichelHitPeakTime);
  fTree->Branch("recoMichel.HitNElectrons",	  &fRecoMichelHitNElectrons);
  fTree->Branch("recoMichel.HitPlane",		&fRecoMichelHitPlane);
  fTree->Branch("recoMIchel.EnergyU",		&fRecoMichelEnergyU);
  fTree->Branch("recoMIchel.EnergyV", 		 &fRecoMichelEnergyV);
  fTree->Branch("recoMIchel.EnergyW",		  &fRecoMichelEnergyW);
  fTree->Branch("recoMichel.EnergyDiffU",	&fRecoMichelEnergyDiffU);
  fTree->Branch("recoMichel.EnergyDiffV",       &fRecoMichelEnergyDiffV);
  fTree->Branch("recoMichel.EnergyDiffW",       &fRecoMichelEnergyDiffW);
  fTree->Branch("recoMichel.IntegralMaxU",	&fRecoMichelIntegralMaxU);
  fTree->Branch("recoMichel.IntegralMeanU",	&fRecoMichelIntegralMeanU);
  fTree->Branch("recoMichel.IntegralSigmaU",	&fRecoMichelIntegralSigmaU);
  fTree->Branch("recoMichel.IntegralMaxV",      &fRecoMichelIntegralMaxV);
  fTree->Branch("recoMichel.IntegralMeanV",     &fRecoMichelIntegralMeanV);
  fTree->Branch("recoMichel.IntegralSigmaV",    &fRecoMichelIntegralSigmaV);
  fTree->Branch("recoMichel.IntegralMaxW",      &fRecoMichelIntegralMaxW);
  fTree->Branch("recoMichel.IntegralMeanW",     &fRecoMichelIntegralMeanW);
  fTree->Branch("recoMichel.IntegralSigmaW",    &fRecoMichelIntegralSigmaW);
  fTree->Branch("recoMichel.MultiplicityMaxV",   &fRecoMichelMultiplicityMaxV);
  fTree->Branch("recoMichel.MultiplicityMeanV",   &fRecoMichelMultiplicityMeanV);
  fTree->Branch("recoMichel.MultiplicitySigmaV",   &fRecoMichelMultiplcitySigmaV);
  fTree->Branch("recoMichel.GOFMaxV",		   &fRecoMichelGOFMaxV);
  fTree->Branch("recoMichel.GOFMeanV",		   &fRecoMichelGOFSigmaV);
  fTree->Branch("recoMichel.GOFSigmaV",		   &fRecoMichelGOFMeanV);
  fTree->Branch("recoMichel.MultiplicityMaxU",	   &fRecoMichelMultiplicityMaxU);
  fTree->Branch("recoMichel.MultiplicityMeanU",	   &fRecoMichelMultiplicityMeanU);
  fTree->Branch("recoMichel.MultiplicitysigmaU",   &fRecoMichelMultiplcitySigmaU);
  fTree->Branch("recoMichel.GOFMaxU",		   &fRecoMichelGOFMaxU);
  fTree->Branch("recoMichel.GOFMeanU",		   &fRecoMichelGOFSigmaU);
  fTree->Branch("recoMichel.GOFSigmaU",		   &fRecoMichelGOFMeanU);
  fTree->Branch("recoMichel.MultiplicityMaxW",	   &fRecoMichelMultiplicityMaxW);
  fTree->Branch("recoMichel.MultiplicityMeanW",	   &fRecoMichelMultiplicityMeanW);
  fTree->Branch("recoMichel.MultiplicitySigmaW",	  &fRecoMichelMultiplcitySigmaW);
  fTree->Branch("recoMichel.GOFMaxW",		   &fRecoMichelGOFMaxW);
  fTree->Branch("recoMichel.GOFMeanW",		   &fRecoMichelGOFSigmaW);
  fTree->Branch("recoMichel.GOFSigmaW",		   &fRecoMichelGOFMeanW);
  fTree->Branch("recoMichel.HitMultiplicity",	&fRecoMichelhitMultiplicity);
  fTree->Branch("recoMichel.HitGOF",		&fRecoMichelHitGOF);
  fTree->Branch("recoMichel.EDiffMin",		&fRecoMichelEDiffMin);
  fTree->Branch("recoMichel.EDiffMinMult",	&fRecoMichelEDiffMinMult);
  fTree->Branch("recoMichel.EDiffMinGOF",	&fRecoMichelEDiffMinGOF);
  fTree->Branch("recoMichel.PurityU",		&fRecoMichelPurityU);
  fTree->Branch("recoMichel.PurityV",           &fRecoMichelPurityV);
  fTree->Branch("recoMichel.PurityW",           &fRecoMichelPurityW);
  fTree->Branch("recoMichel.EPurityU",		&fRecoMichelEPurityU);
  fTree->Branch("recoMichel.EPurityV",          &fRecoMichelEPurityV);
  fTree->Branch("recoMichel.EPurityW",          &fRecoMichelEPurityW);
  fTree->Branch("recoMichel.PlaneIndex",	&fRecoMichelPlaneIndex);
  fTree->Branch("recoMichel.EnergyVect",		&fRecoMichelEnergyVect);
  fTree->Branch("recoMichel.EnergyDiffVect",		&fRecoMichelEnergyDiffVect);
  fTree->Branch("recoMichel.EPurityVect",		&fRecoMichelEPurityVect);
  fTree->Branch("recoMichel.EPurity",			&fRecoMichelEPurity);
  fTree->Branch("recoMichel.PurityVect",          	&fRecoMichelPurityVect);
  fTree->Branch("recoMichel.CompletenessVect",          &fRecoMichelcompletenessVect);
  fTree->Branch("recoMichel.GOFMeanVect",          	&fRecoMichelGOFMeanVect);
  fTree->Branch("recoMichel.GOFSigmaVect",          	&fRecoMichelGOFSigmaVect);
  fTree->Branch("recoMichel.GOFMaxVect",          	&fRecoMichelGOFMaxVect);
    fTree->Branch("recoMichel.MultMeanVect",          	&fRecoMichelMultMeanVect);
  fTree->Branch("recoMichel.MultSigmaVecy",          	&fRecoMichelMultSigmaVect);
  fTree->Branch("recoMichel.MultMaxVect",          	&fRecoMichelMultMaxVect);
  fTree->Branch("recoMichel.IntegralMeanVect",          	&fRecoMichelIntegralMeanVect);
  fTree->Branch("recoMichel.IntegralSigmaVect",          	&fRecoMichelIntegralSigmaVect);
  fTree->Branch("recoMichel.IntegralMaxVect",		&fRecoMichelIntegralMaxVect);
  fTree->Branch("recoMichel.NHitsVect",			&fRecoMichelNHitsPlane);
  fTree->Branch("recoMichel.StartDir",			&fRecoMichelStartVect);

  // MC Muon
  fTree->Branch("mcMuon.G4ID",			&fMCMuonG4ID);
  fTree->Branch("mcMuon.NDeltas", 		&fNDeltas);
  fTree->Branch("mcMuon.NPoints", 		&fNPoints);
  fTree->Branch("mcMuon.Energy", 		&fMCMuonEnergy);
  fTree->Branch("mcMuon.Theta", 		&fMCMuonTheta);
  fTree->Branch("mcMuon.Phi", 			&fMCMuonPhi);
  fTree->Branch("mcMuon.Vect", 			&fMCMuonVect);
  fTree->Branch("mcMuon.EndX",			&fMCMuonEndX);
  fTree->Branch("mcMuon.EndY",			&fMCMuonEndY);
  fTree->Branch("mcMuon.EndZ",			&fMCMuonEndZ);
  fTree->Branch("mcMuon.EndEnergy",		&fMCMuonEndEnergy);
  fTree->Branch("mcMuon.EndPx",			&fMCMuonEndPx);
  fTree->Branch("mcMuon.EndPy",			&fMCMuonEndPy);
  fTree->Branch("mcMuon.EndPz",			&fMCMuonEndPz);
  fTree->Branch("mcMuon.StartX",		&fMCMuonStartX);
  fTree->Branch("mcMuon.StartY",		&fMCMuonStartY);
  fTree->Branch("mcMuon.StartZ",		&fMCMuonStartZ);
  fTree->Branch("mcMuon.Bendiness",		&fMCMuonBendiness);

  // Reco Muon
  fTree->Branch("recoMuon,NHits",		&fNRecoMuonHits);
  fTree->Branch("recoMuon.Energy", 		&fRecoMuonEnergy);
  fTree->Branch("recoMuon.Theta", 		&fRecoMuonTheta);
  fTree->Branch("recoMuon.Phi", 		&fRecoMuonPhi);
  fTree->Branch("recoMuon.Vect", 		&fRecoMuonVect);
  fTree->Branch("recoMuon.ID", 			&fRecoMuonID);
  fTree->Branch("recoMuon.StartX", 		&fRecoMuonStartX);
  fTree->Branch("recoMuon.StartY",		&fRecoMuonStartY);
  fTree->Branch("recoMuon.StartZ",		&fRecoMuonStartZ);
  fTree->Branch("recoMuon.EndX",		&fRecoMuonEndX);
  fTree->Branch("recoMuon.EndY",		&fRecoMuonEndY);
  fTree->Branch("recoMuon.EndZ",		&fRecoMuonEndZ);
  fTree->Branch("recoMuon.CheckHits",		&fRecoMuonCheckHits);
  fTree->Branch("recoMuon.IsPrimary",		&fRecoMuonIsPrimary);
  fTree->Branch("recoMuon.Mother",		&fRecoMuonMother);
  fTree->Branch("recoMuon.NTrueHits",		&fNTrueHitsInRecoMuon);
  fTree->Branch("recoMuon.Azimuth",		&fRecoMuonAzi);
  fTree->Branch("recoMuon.Zenith",		&fRecoMuonZen);
  fTree->Branch("recoMuon.EndX",		&fRecoMuonEndX);
  fTree->Branch("recoMuon.EndY",		&fRecoMuonEndY);
  fTree->Branch("recoMuon.EndZ",		&fRecoMuonEndZ);
  fTree->Branch("recoMuon.NClusters",		&fRecoMuonNClusters);
  fTree->Branch("recoMuon.NHitsVect",		&fRecoMuonNHitsPlane);
  fTree->Branch("recoMuon.EndBendinessVect",	&fRecoMuonEndBendinessVect);
  fTree->Branch("recoMuon.EndDir",		&fRecoMuonEndVect);

  fTree->Branch("nonClust.X",			&fNonClustX);
  fTree->Branch("nonClust.Y",                   &fNonClustY);
  fTree->Branch("nonClust.Z",                   &fNonClustZ);
 fTree->Branch("nonClust.Dist",                   &fNonClustDist);
  fTree->Branch("nonClust.MaxAmp",                &fNonClustMaxAmp);
  fTree->Branch("nonClust.SADC",                   &fNonClustSADC);
  fTree->Branch("nonClust.Plane",                   &fNonClustPlane);
  fTree->Branch("nonClust.IsMichel",		&fNonClustIsMichel);

  fTree->Branch("countpfpf",				&countpfps);
  fTree->Branch("lastchar",				&lastchar);

  fMCMichelEnergyHist = tfs->make<TH1D>("mcMichelEnergyHist", "Energy of MC Michels; Energy; Events", 40, 2, 1);
  fMCMuonEnergyHist = tfs->make<TH1D>("mcMuonEnergyHist", "Energy of MC muons; Energy; Events", 40, 2, 1);
  fRecoMuonEnergyHist = tfs->make<TH1D>("recoMichelEnergyHist", "Energy of reconstructed Michels; Energy; Events", 40, 2, 1);
  fRecoMichelEnergyHist = tfs->make<TH1D>("recoMuonEnergyHist", "Energy of reconstructed muons; Energy; Events", 40, 2, 1);
  fMCMichelThetaHist = tfs->make<TH1D>("mcMichelThetahist", "Theta of MC Michels; Theta; Events", 40, 2, 1);
  fMCMuonThetaHist = tfs->make<TH1D>("mcMuonThetaHist", "Theta of MC muons; Theta; Events", 40, 2, 1);
  fRecoMichelThetaHist = tfs->make<TH1D>("recoMichelThetaHist", "Theta of reconstructed Michels; Theta; Events", 40, 2, 1);
  fRecoMuonThetaHist = tfs->make<TH1D>("recoMuonThetaHist", "Theta of reconstructed muons; Theta; Events", 40, 2, 1);
  fMCMichelPhiHist = tfs->make<TH1D>("mcMichelPhiHist", "Phi of MC Michels; Phi; Events", 40, 2, 1);
  fMCMuonPhiHist = tfs->make<TH1D>("mcMuonPhiHist", "Phi of MC muons; Phi; Events", 40, 2, 1);
  fRecoMichelPhiHist = tfs->make<TH1D>("recoMichelPhiHist", "Phi of reconstructed Michels; Phi; Events", 40, 2, 1);
  fRecoMuonPhiHist = tfs->make<TH1D>("recoMuonHist", "Phi of reconstructed muons; Phi; Events", 40, 2, 1);
  fMCMichelRelThetaHist = tfs->make<TH1D>("mcMichelRelThetaHist", "Theta difference between MC Michel and muon; Theta; Events", 40, 2, 1);
  fRecoMichelRelThetaHist = tfs->make<TH1D>("recoMichelRelThetaHist", "Theta difference between reconstructed Michel and muon; Theta; Events", 40, 2, 1);
  fMCMichelRelPhiHist = tfs->make<TH1D>("mcMichelRelPhiHist", "Phi difference between MC Michel and muon; Phi; Events", 40, 2, 1);
  fRecoMichelRelPhiHist = tfs->make<TH1D>("recoMichelRelHist", "Phi difference between reconstructed Michel and muon; Phi; Events", 40, 2, 1);
  fMCMichelLengthHist = tfs->make<TH1D>("mcMichelLengthHist", "Length of MC Michels; Length; Events", 40, 4, 3);
}

void sbnd::AnalyzeMichels::endJob()
{}

void sbnd::AnalyzeMichels::ResetVars()
{
  // Reset all of our variables to 0 or empty vectors
  // This ensures things are not kept from the previous event
  fNPFParticles = 0;
  fNDeltas = 0;
  fMCMichelID = 0;
  fNTotalMichelHits= 0;
  fNHitsInRecoMichel = 0;
  fEventNHits = 0;
  fEventNClusterHits = 0;
  fPurity = 0;
  fCompleteness = 0;
  fNTrueHitsInRecoMichel = 0;
  fNPoints = 0;
  fNShowers = 0;
  fNTracks = 0;
  fRecoMichel = false;
  fIsTrack = false;
  fIsShower = false;
  fShowerPurity = 0;
  fTrackPurity = 0;
  fShowerBestPlane = 0;
  fRecoMichelID = 0;
  fRecoMuonID = -1;
  fNRecoMuonHits = 0;
  fNRecoElectrons = 0;
  fWrongMuonEnd = false;
  fMCMichelStartX = 0;
  fMCMichelStartY = 0;
  fMCMichelStartZ = 0;
  fRecoMichelStartX = 0;
  fRecoMichelStartY = 0;
  fRecoMichelStartZ = 0;
  fMCMuonG4ID = -9999;
  fMCMuonEndX = 0;
  fMCMuonEndY = 0;
  fMCMuonEndZ = 0;
  fRecoMuonStartX = 0;
  fRecoMuonStartY = 0;
  fRecoMuonStartZ = 0;
  fRecoMuonEndX = 0;
  fRecoMuonEndY = 0;
  fRecoMuonEndZ = 0;
  fRecoMichelMother = -1;
  fRecoMuonCheckHits = 0;
  fNRecoMichelSpacePoints = 0;
  fRecoMichelNHitsPlane = {-1, -1, -1};
  fNMuons = 0;
  fRecoMuonIsPrimary = false;
  fRecoMuonMother = -1;
  fRecoMuonMichelDist = 0;
  fNTrueHitsInRecoMuon = 0;
  fNMuonsWithTrueHits = 0;
  fNElectronsWithTrueHits = 0;
  fRecoMichelLength = 0;
  fRecoMichelAzi = 0;
  fRecoMichelZen = 0;
  fRecoMuonTheta = 0;
  fRecoMuonPhi = 0;
  fRecoMuonAzi = 0;
  fRecoMuonZen = 0;
  fMaxSADCX = 0;
  fMaxSADCY = 0;
  fMaxSADCZ = 0;
  fMaxSADCDist = 0;
  fMaxAmpX = 0;
  fMaxAmpY = 0;
  fMaxAmpZ = 0;
  fMaxAmpDist = 0;
  fMCMichelRelAngle = 0;
  fMCMichelNPoints = 0;
  fMCMuonEndEnergy = 0;
  fMCMichelEnergyFrac = 0;
  fMCMuonEndPx = 0;
  fMCMuonEndPy = 0;
  fMCMuonEndPz = 0;
  fMCMuonStartX = 0;
  fMCMuonStartY = 1000;
  fMCMuonStartZ = 0;
  fRecoMichelCloseProximity = -1;
  fRecoMichelNClusters = 0;
  fRecoMuonNClusters = 0;
  fMCMuonBendiness = 0;
  fRecoMichelEnergySigma = 0;
  fRecoMicheldEdX.clear();
  fAmpMean = 0;
  fAmpSigma = 0;
  fSADCMean = 0;
  fSADCSigma = 0;
  fNMichelNonClust = 0;
   fRecoMichelMultiplicityMaxV = 0;
   fRecoMichelMultiplicityMeanV = 0;
   fRecoMichelMultiplcitySigmaV = 0;
   fRecoMichelGOFMaxV = 0;
   fRecoMichelGOFSigmaV = 0;
   fRecoMichelGOFMeanV = 0;
   fRecoMichelMultiplicityMaxU = 0;
   fRecoMichelMultiplicityMeanU = 0;
   fRecoMichelMultiplcitySigmaU = 0;
   fRecoMichelGOFMaxU = 0;
   fRecoMichelGOFSigmaU = 0;
   fRecoMichelGOFMeanU = 0;
   fRecoMichelMultiplicityMaxW = 0;
   fRecoMichelMultiplicityMeanW = 0;
   fRecoMichelMultiplcitySigmaW = 0;
   fRecoMichelGOFMaxW = 0;
   fRecoMichelGOFSigmaW = 0;
   fRecoMichelGOFMeanW = 0;
  countpfps = 0;
  fNSlices = 0;
  fRecoMuonEndBendinessVect = {-1, -1, -1};
  fRecoMichelhitMultiplicity.clear();
  fRecoMichelHitGOF.clear();
  fRecoMichelPurityU = 0;
  fRecoMichelPurityV = 0;
  fRecoMichelPurityW = 0;
  fRecoMichelEPurityU = 0;
  fRecoMichelEPurityV = 0;
  fRecoMichelEPurityW = 0;
  fRecoMichelPlaneIndex = {0, 1, 2};
  fRecoMichelEPurityVect = {-1, -1, -1};
  fRecoMichelEPurity = 0;
  fRecoMichelEnergyVect = {-1 , -1 , -1};
  fRecoMichelEnergyDiffVect = {-1 , -1 , -1};
  fRecoMichelPurityVect = {-1, -1, -1};
  fRecoMichelcompletenessVect = {-1, -1, -1};
  fRecoMichelGOFMeanVect = {-1, -1, -1};
  fRecoMichelGOFSigmaVect = {-1, -1, -1};
  fRecoMichelGOFMaxVect = {-1, -1, -1};
  fRecoMichelMultMeanVect = {-1, -1, -1};
  fRecoMichelMultSigmaVect = {-1, -1, -1};
  fRecoMichelMultMaxVect = {-1, -1, -1};
  fRecoMichelIntegralMeanVect = {-1, -1, -1};
  fRecoMichelIntegralSigmaVect = {-1, -1, -1};
  fRecoMichelIntegralMaxVect = {-1, -1, -1};

  fRecoMichelEnergyDiffU = 0;
  fRecoMichelEnergyDiffV = 0;
  fRecoMichelEnergyDiffW = 0;
  fRecoMichelIntegralMaxU = 0;
  fRecoMichelIntegralMeanU = 0;
  fRecoMichelIntegralSigmaU = 0;
  fRecoMichelIntegralMaxV = 0;
  fRecoMichelIntegralMeanV = 0;
  fRecoMichelIntegralSigmaV = 0;
  fRecoMichelIntegralMaxW = 0;
  fRecoMichelIntegralMeanW = 0;
  fRecoMichelIntegralSigmaW = 0;
  fRecoMichelEDiffMin = 0;
  fRecoMichelEDiffMinGOF = 0;
  fRecoMichelEDiffMinMult = 0;

  fRecoMichelHitIntegral.clear();
  fRecoMichelHitPeakTime.clear();
  fRecoMichelHitNElectrons.clear();
  fRecoMichelHitPlane.clear();
  fRecoMichelEnergyU = 0;
  fRecoMichelEnergyV = 0;
  fRecoMichelEnergyW = 0;

  fPFParticlePDG.clear();
  fMCPDG.clear();
  fMCTrackID.clear();
  fNHitsInPFP.clear();
  fNTrueHitsInPFP.clear();
  fNClusters.clear();
  fClusterID.clear();
  fClusterPlane.clear();

  fMCMichelEnergy = 0;
  fMCMuonEnergy = 0;
  fRecoMuonEnergy = 0;
  fRecoMichelEnergy = 0;
  fMCMichelTheta = 0;
  fMCMuonTheta = 0;
  fRecoMichelTheta = 0;
  fMCMuonPhi = 0;
  fRecoMichelPhi = 0;
  fRecoMuonPhi = 0;
  fMCMichelRelTheta = 0;
  fRecoMichelRelTheta = 0;
  fMCMichelRelPhi = 0;
  fRecoMichelRelPhi = 0;
  fRecoMichelRelAngle = 0.0;
  fMCMichelLength = 0;
   lastchar = "a";
  fPFPIsPrimary.clear();
  fPFPMother.clear();

  fRecoMuonEndX = 0;
  fRecoMuonEndY = 0;
  fRecoMuonEndZ = 0;

  fNonClustX.clear();
  fNonClustY.clear();
  fNonClustZ.clear();
  fNonClustDist.clear();             // Distance of non-clustered hit to MC Michel start
  fNonClustMaxAmp.clear();
  fNonClustSADC.clear();
  fNonClustPlane.clear();
  fNonClustIsMichel.clear();
}


void sbnd::AnalyzeMichels::FillMC(const art::Ptr<simb::MCParticle>& mcp,
                                  std::vector<art::Ptr<simb::MCParticle>>& mctruthVect)
{
  fMCMuonG4ID = mcp->TrackId();
  fNPoints = mcp->NumberTrajectoryPoints();
  unsigned int i =  fNPoints/2;
  unsigned int j = fNPoints-1;
  unsigned int firstquart = fNPoints/4;
  unsigned int lastquart = 3*fNPoints/4;
  TVector3 tempvect = mcp->Position(0).Vect();
  TVector3 mcmuonend = mcp->EndPosition().Vect();

  TVector3 vect1 = (mcp->Position(firstquart).Vect() - mcp->Position(0).Vect()).Unit();
  TVector3 vect2 = (mcp->Position(i).Vect() - mcp->Position(firstquart).Vect()).Unit();
  TVector3 vect3 = (mcp->Position(lastquart).Vect() - mcp->Position(i).Vect()).Unit();
  TVector3 vect4 = (mcp->Position(j).Vect() - mcp->Position(lastquart).Vect()).Unit();
  fMCMuonBendiness = (vect1.Dot(vect2) + vect2.Dot(vect3) + vect3.Dot(vect4))/3;

  *fMCMuonVect = mcp->Position(i).Vect() - mcp->Position(j).Vect();
  TVector3 fMCMuonEndVect = mcp->Position(j).Vect();
  fMCMuonEndX = fMCMuonEndVect.X();
  fMCMuonEndY = fMCMuonEndVect.Y();
  TVector3 fMCMuonStartVect = mcp->Position(0).Vect();
  fMCMuonStartX = fMCMuonStartVect.X();
  fMCMuonStartY = fMCMuonStartVect.Y();
  fMCMuonStartZ = fMCMuonStartVect.Z();
  fMCMuonEndZ = fMCMuonEndVect.Z();
  rotateVector(fMCMuonVect);
  fMCMuonTheta = (fMCMuonVect->Theta()) * 180 / M_PI -90; 		// Minus sign is there as muons are coming down;
  rotateVector(fMCMuonVect);
  fMCMuonPhi = (fMCMuonVect->Theta()) * 180 / M_PI -90;
  rotateVector(fMCMuonVect);
  fMCMuonEnergy = mcp->E() * 1000;				// Scale energy to MeV
  fMCMuonEndEnergy = mcp->EndE() * 1000;
  fMCMuonEnergyHist->Fill(fMCMuonEnergy);
  fMCMuonThetaHist->Fill(fMCMuonTheta);
  fMCMuonPhiHist->Fill(fMCMuonPhi);
  fMCMuonEndPx = mcp->EndPx();
  fMCMuonEndPy = mcp->EndPy();
  fMCMuonEndPz = mcp->EndPz();
  
  for(auto& mcp2 : mctruthVect) {
    if(abs(mcp2->PdgCode()) == 11 &&  mcp2->Mother() == fMCMuonG4ID) {
      if(mcp2->Position(0).Vect().X() != fMCMuonEndX ||
        mcp2->Position(0).Vect().Y() != fMCMuonEndY ||
        mcp2->Position(0).Vect().Z() != fMCMuonEndZ) continue;
      fMCMichelNPoints = mcp2->NumberTrajectoryPoints();  
      unsigned int i  = mcp2->NumberTrajectoryPoints() -1;
      unsigned int j = mcp2->NumberTrajectoryPoints() / 2;
      fMCMichelID = mcp2->TrackId();
      fMCMichelEnergy = mcp2->E() * 1000;
      fMCMichelEnergyHist->Fill(fMCMichelEnergy);
      TVector3 fMCMichelStartVect = mcp2->Position(0).Vect();
      fMCMichelStartX = fMCMichelStartVect.X();
      fMCMichelStartY = fMCMichelStartVect.Y();
        fMCMichelStartZ = fMCMichelStartVect.Z();
      if(fMCMichelNPoints < 10) {
       *fMCMichelVect = mcp2->Position(0).Vect() - mcp2->Position(i).Vect();
      } else {*fMCMichelVect = mcp2->Position(0).Vect() - mcp2->Position(j).Vect();
      } 
      rotateVector(fMCMichelVect);
      fMCMichelTheta = (fMCMichelVect->Theta()) * 180 / M_PI - 90;
      rotateVector(fMCMichelVect);
      fMCMichelPhi = (fMCMichelVect->Theta()) * 180 / M_PI - 90;
      rotateVector(fMCMichelVect);
      fMCMichelLength = (mcp2->Position(0).Vect() - mcp2->Position(i).Vect()).Mag();
      fMCMichelLengthHist->Fill(fMCMichelLength);
      fMCMichelRelTheta = fMCMichelTheta - fMCMuonTheta;
      fMCMichelRelPhi = fMCMichelPhi - fMCMuonPhi;
      fMCMichelRelThetaHist->Fill(fMCMichelRelTheta);
      fMCMichelRelPhiHist->Fill(fMCMichelRelPhi);
      fMCMichelEnergyFrac = fMCMichelEnergy / fMCMuonEndEnergy;
    }
  }
}

void sbnd::AnalyzeMichels::FillRecoMuon()
{
  art::Handle<std::vector<recob::Track>> trackHandle;
  std::vector<art::Ptr<recob::Track>> trackVec;
  if (e.getByLabel(fTrackLabel, trackHandle))
    art::fill_ptr_vector(trackVec, trackHandle);

  for(const art::Ptr<recob::Track> &track : trackVec) {     	// Loop over PFPs in event
    int NTrueHitsInPFP = 0;
    int NMuonHitsInPFP = 0;
    std::vector< art::Ptr<recob::Cluster> > pfpCluster = clusterAssoc.at(track.key());  
    std::vector< art::Ptr<recob::Hit> > hitsFromPFPVect;
    fNClusters.push_back(pfpCluster.size());
    int NClusters = 0;
    fPFParticlePDG.push_back(track->PdgCode());
    if(pfpCluster.empty()) continue;
    for(const art::Ptr<recob::Cluster> &clust : pfpCluster) {     // For each cluster
      std::vector< art::Ptr<recob::Hit> > clusterHits = hitAssoc.at(clust.key());
      if(clusterHits.empty()) continue;
      std::string clusterplane = clust->Plane().toString();
      lastchar = clusterplane.back();
      if(sUseWPlaneOnly==1) {
        if(lastchar=="2") {
          hitsFromPFPVect.insert(hitsFromPFPVect.end(), clusterHits.begin(), clusterHits.end());  
          fClusterID.push_back(clust->ID());
          fClusterPlane.push_back(lastchar);
          NClusters++;
        }
      } else {
          hitsFromPFPVect.insert(hitsFromPFPVect.end(), clusterHits.begin(), clusterHits.end());
          fClusterID.push_back(clust->ID());
          fClusterPlane.push_back(lastchar);
          NClusters++;        
      }
    }
    for (const art::Ptr<recob::Hit> &hit : hitsFromPFPVect) {		// Loop over individual hits in each PFP
      hitno++;
      std::vector< art::Ptr<recob::SpacePoint> > hitPoints = spacepointAssoc.at(hit.key());
      if(hitPoints.empty()) continue;
      spacepointsFromPFPVect.insert(spacepointsFromPFPVect.end(), hitPoints.begin(), hitPoints.end());

      int hitid = RecoUtils::TrueParticleID(clockData, hit);
      if(hitid==fMCMuonG4ID) NMuonHitsInPFP++;			// Reco Muon normally found on second run of PFP for loop 
      if(hitid==fMCMichelG4ID) NTrueHitsInPFP++;
      if(!hitPoints.empty()) {
        for (const art::Ptr<recob::SpacePoint> &spacepoint : hitPoints) {
          current_sp.SetXYZ(spacepoint->XYZ()[0], spacepoint->XYZ()[1], spacepoint->XYZ()[2]);
      }  
      curdist = (current_sp - last_sp).Mag();
        if(curdist < mindist) mindist = curdist;
        last_sp = current_sp;
      }
    }
      
    if(NMuonHitsInPFP > fRecoMuonHitsInRecoMuon) {
      fNRecoMuonHits = NMuonHitsInPFP;
      RecoMuonHits = hitsFromPFPVect;
      fRecoMuonNClusters = NClusters;
      fNRecoMuonSpacePoints = RecoMuonSpacePoints.size();
      fNTrueHitsInRecoMuon = NTrueHitsInPFP;
      muonTrack = trackAssoc.at(track.key());
      fRecoMuonHitsInRecoMuon = NMuonHitsInPFP;
    }
    fNHitsInPFP.push_back(hitno);
    fNTrueHitsInPFP.push_back(NTrueHitsInPFP);
    fRecoMuonIsPrimary = pfp->IsPrimary();
    fRecoMuonMother = pfp->Parent();
    fPFPIsPrimary.push_back(pfp->IsPrimary());
    fPFPMother.push_back(pfp->Parent());
    if(pdg==11&&NTrueHitsInPFP>0) {
      fNElectronsWithTrueHits++;
    } else {
      if(pdg==13&&NTrueHitsInPFP>0) fNMuonsWithTrueHits++;
    }
  }
}

DEFINE_ART_MODULE(sbnd::AnalyzeMichels)
